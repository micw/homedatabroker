package de.wyraz.tibberpulse.sml;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatCode;

import java.io.IOException;

import org.apache.commons.codec.binary.Hex;
import org.junit.Test;

import de.wyraz.sml.asn1.ASN1BERTokenizer;

public class SMLDecoderTests {

	static {
		SMLDecoder.DUMP_RAW_SML=true;
	}
	
	@Test
	public void testSMLDecoderInvalidStartSequence() throws Exception {
		String payload="1c1b1b1b010101017605128e14cf620062007265000001017601010765425a4444330b090145425a0100091f14010163df26007605128e14d06200620072650000070177010b090145425a0100091f14017262016505e465007a77078181c78203ff010101010445425a0177070100000009ff010101010b090145425a0100091f140177070100010800ff6401018001621e52fb69000002a05939af070177070100010801ff0101621e52fb69000002a0531f2f070177070100010802ff0101621e52fb6900000000061a80000177070100020800ff6401018001621e52fb69000000000d7b8b460177070100100700ff0101621b52fe5500013c060177070100240700ff0101621b52fe55000058f00177070100380700ff0101621b52fe55000085f901770701004c0700ff0101621b52fe5500005d1d010101636c93007605128e14d162006200726500000201710163c682000000001b1b1b1b1a032f09";
		
		assertThatCode(()->{
			SMLDecoder.decode(Hex.decodeHex(payload));
		})
			.isInstanceOf(IOException.class)
			.hasMessageStartingWith("Invalid SML payload: 1c1b1b1");
	}
	@Test
	public void testSMLDecoderInvalidEndSequence() throws Exception {
		String payload="1b1b1b1b010101017605128e14cf620062007265000001017601010765425a4444330b090145425a0100091f14010163df26007605128e14d06200620072650000070177010b090145425a0100091f14017262016505e465007a77078181c78203ff010101010445425a0177070100000009ff010101010b090145425a0100091f140177070100010800ff6401018001621e52fb69000002a05939af070177070100010801ff0101621e52fb69000002a0531f2f070177070100010802ff0101621e52fb6900000000061a80000177070100020800ff6401018001621e52fb69000000000d7b8b460177070100100700ff0101621b52fe5500013c060177070100240700ff0101621b52fe55000058f00177070100380700ff0101621b52fe55000085f901770701004c0700ff0101621b52fe5500005d1d010101636c93007605128e14d162006200726500000201710163c682000000001c1b1b1b1a032f09";
		
		assertThatCode(()->{
			SMLDecoder.decode(Hex.decodeHex(payload));
		})
			.isInstanceOf(IOException.class)
			.hasMessageStartingWith("Invalid SML payload: 1b1b1b1");
	}
	@Test
	public void testSMLDecoderInvalidCRC() throws Exception {
		String payload="1b1b1b1b010101017605128e14cf620062007265000001017601010765425a4444330b090145425a0100091f14010163df26007605128e14d06200620072650000070177010b090145425a0100091f14017262016505e465007a77078181c78203ff010101010445425a0177070100000009ff010101010b090145425a0100091f140177070100010800ff6401018001621e52fb69000002a05939af070177070100010801ff0101621e52fb69000002a0531f2f070177070100010802ff0101621e52fb6900000000061a80000177070100020800ff6401018001621e52fb69000000000d7b8b460177070100100700ff0101621b52fe5500013c060177070100240700ff0101621b52fe55000058f00177070100380700ff0101621b52fe55000085f901770701004c0700ff0101621b52fe5500005d1d010101636c93007605128e14d162006200726500000201710163c682000000001b1b1b1b1a032f08";
		
		assertThatCode(()->{
			SMLDecoder.decode(Hex.decodeHex(payload));
		})
			.isInstanceOf(IOException.class)
			.hasMessage("Invalid SML payload: wrong crc");
	}
	
	/**
	 * Initial test with data from my own meter
	 */
	@Test
	public void testSMLDecoderEBZ() throws Exception {
		String payload="1b1b1b1b010101017605128e14cf620062007265000001017601010765425a4444330b090145425a0100091f14010163df26007605128e14d06200620072650000070177010b090145425a0100091f14017262016505e465007a77078181c78203ff010101010445425a0177070100000009ff010101010b090145425a0100091f140177070100010800ff6401018001621e52fb69000002a05939af070177070100010801ff0101621e52fb69000002a0531f2f070177070100010802ff0101621e52fb6900000000061a80000177070100020800ff6401018001621e52fb69000000000d7b8b460177070100100700ff0101621b52fe5500013c060177070100240700ff0101621b52fe55000058f00177070100380700ff0101621b52fe55000085f901770701004c0700ff0101621b52fe5500005d1d010101636c93007605128e14d162006200726500000201710163c682000000001b1b1b1b1a032f09";
		
		SMLMeterData data=SMLDecoder.decode(Hex.decodeHex(payload));
		
		assertThat(data).isNotNull();
		
		assertThat(data.getMeterId()).isEqualTo("1EBZ0100597780");
		
		assertThat(data.getReadings())
			.isNotNull()
			.extracting(Object::toString)
			.containsExactlyInAnyOrder(
					  "1-0:1.8.0*255 / energyImportTotal = 28877149.75495 WATT_HOUR",
					  "1-0:1.8.1*255 / energyImportTariff1 = 28876125.75495 WATT_HOUR",
					  "1-0:1.8.2*255 / energyImportTariff2 = 1024.00000 WATT_HOUR",
					  "1-0:2.8.0*255 / energyExportTotal = 2262.00390 WATT_HOUR",
					  "1-0:16.7.0*255 / powerTotal = 809.02 WATT",
					  "1-0:36.7.0*255 / powerL1 = 227.68 WATT",
					  "1-0:56.7.0*255 / powerL2 = 342.97 WATT",
					  "1-0:76.7.0*255 / powerL3 = 238.37 WATT"
					);
		
	}
	
	/**
	 * Initial test with data from my new meter
	 */
	@Test
	public void testSMLDecoderEFR() throws Exception {
		String payload="1b1b1b1b010101017605000022e06200620072630101760107ffffffffffff0500000ba10b0a0145465223047b7d5f7262016500000bb00163ca40007605000022e162006200726307017707ffffffffffff0b0a0145465223047b7d5f070100620affff7262016500000bb078770701006032010101010101044546520177070100600100ff010101010b0a0145465223047b7d5f0177070100010800ff65001c79047262016500000bb0621e52ff69000000000000071e0177070100020800ff017262016500000bb0621e52ff69000000000000aaf5017707010000020000010101010630312e30380177070100605a0201010101010530434632017707010000020001010101010630312e31310177070100605a0202010101010533454630010101639c9b007605000022e26200620072630201710163a627001b1b1b1b1a00227a";
		
		SMLMeterData data=SMLDecoder.decode(Hex.decodeHex(payload));
		
		assertThat(data).isNotNull();
		
		
		assertThat(data.getMeterId()).isEqualTo("1EFR3575201887");
		
		assertThat(data.getReadings())
			.isNotNull()
			.extracting(Object::toString)
			.containsExactlyInAnyOrder(
					  "1-0:1.8.0*255 / energyImportTotal = 182.2 WATT_HOUR",
					  "1-0:2.8.0*255 / energyExportTotal = 4376.5 WATT_HOUR");
		
	}
	
	
	@Test
	public void testSMLDecoderEFR_short() throws Exception {
		String payload="1b1b1b1b010101017605080e16b66200620072630101760107ffffffffffff0502af5ce80b0a014546522102cd630c7262016502af5ce5016333fe007605080e16b762006200726307017707ffffffffffff0b0a014546522102cd630c070100620affff7262016502af5ce579770701006032010101010101044546520177070100600100ff010101010b0a014546522102cd630c0177070100010800ff641c40047262016502af5ce5621e52ff65016d58b80177070100020800ff017262016502af5ce5621e52ff650286c57c017707010000020000010101010630332e30300177070100605a0201010101010342bd01770701006161000001010101030000017707010060320104010101010850312e322e31320177070100603204040101010103042201010163c14a007605080e16b862006200726302017101639568000000001b1b1b1b1a0309d3";
				
		SMLMeterData data=SMLDecoder.decode(Hex.decodeHex(payload));
		
		System.err.println(data);
		
		assertThat(data).isNotNull();
		
		assertThat(data.getMeterId()).isEqualTo("1EFR3347014668");
		
		assertThat(data.getReadings())
			.isNotNull()
			.extracting(Object::toString)
			.containsExactlyInAnyOrder(
					 "1-0:1.8.0*255 / energyImportTotal = 2394335.2 WATT_HOUR",
					 "1-0:2.8.0*255 / energyExportTotal = 4238681.2 WATT_HOUR"
					);

	}
	
	@Test
	public void testSMLDecoderEFR_long() throws Exception {
		String payload="1b1b1b1b010101017605080e4fb36200620072630101760107ffffffffffff0502af6fe70b0a014546522102cd630c7262016502af6fe40163ca28007605080e4fb462006200726307017707ffffffffffff0b0a014546522102cd630c070100620affff7262016502af6fe4f106770701006032010101010101044546520177070100600100ff010101010b0a014546522102cd630c0177070100010800ff641c58047262016502af6fe4621e52ff65016d59500177070100020800ff017262016502af6fe4621e52ff650286c63b0177070100100700ff0101621b520052f70177070100200700ff0101622352ff6309310177070100340700ff0101622352ff63093a0177070100480700ff0101622352ff63093701770701001f0700ff0101622152fe62680177070100330700ff0101622152fe62b80177070100470700ff0101622152fe62740177070100510701ff01016208520052790177070100510702ff0101620852005300ee0177070100510704ff010162085200530108017707010051070fff010162085200530120017707010051071aff0101620852005300e301770701000e0700ff0101622c52ff6301f4017707010000020000010101010630332e30300177070100605a0201010101010342bd01770701006161000001010101030000017707010060320104010101010850312e322e313201770701006032040401010101030422010101635256007605080e4fb56200620072630201710163fa1200001b1b1b1b1a01fd46";

		SMLMeterData data=SMLDecoder.decode(Hex.decodeHex(payload));
		
		System.err.println(data);
		
		assertThat(data).isNotNull();
		
		assertThat(data.getMeterId()).isEqualTo("1EFR3347014668");
		
		assertThat(data.getReadings())
			.isNotNull()
			.extracting(Object::toString)
			.containsExactlyInAnyOrder(
					 "1-0:1.8.0*255 / energyImportTotal = 2394350.4 WATT_HOUR",
					 "1-0:2.8.0*255 / energyExportTotal = 4238700.3 WATT_HOUR",
					 "1-0:16.7.0*255 / powerTotal = -9 WATT",
					 "1-0:32.7.0*255 / voltageL1 = 235.3 VOLT",
					 "1-0:52.7.0*255 / voltageL2 = 236.2 VOLT",
					 "1-0:72.7.0*255 / voltageL3 = 235.9 VOLT",
					 "1-0:31.7.0*255 / currentL1 = 1.04 AMPERE",
					 "1-0:51.7.0*255 / currentL2 = 1.84 AMPERE",
					 "1-0:71.7.0*255 / currentL3 = 1.16 AMPERE",
					 "1-0:81.7.1*255 / phaseAngleUL2toUL1 = 121 DEGREE",
					 "1-0:81.7.2*255 / phaseAngleUL3toUL1 = 238 DEGREE",
					 "1-0:81.7.4*255 / phaseAngleIL1toUL1 = 264 DEGREE",
					 "1-0:81.7.15*255 / phaseAngleIL2toUL2 = 288 DEGREE",
					 "1-0:81.7.26*255 / phaseAngleIL3toUL3 = 227 DEGREE",
					 "1-0:14.7.0*255 / networkFrequency = 50.0 HERTZ"
				);

	}
	
	@Test
	public void testSMLDecoderHYL_invalidMessage() throws Exception {
		// invalid SML structure (but "well known spec violation") - add a workaround
		String payload="1b1b1b1b0101010176040000016200620072650000010176010107000005e370330b0a01484c59020005dc4b010163d7210076040000026200620072650000070177010b0a01484c59020005dc4b01017c77070100603201010101010104484c590177070100600100ff010101010b0a01484c59020005dc4b0177070100010800ff65000000046505e37033621e52ff6504c2bfcc0177070100020800ff65000000046505e37033621e52ff65002d3d840177070100100700ff0101621b520052000177070100200700ff0101622352ff63090301770701001f0700ff0101622152fe62000177070100510704ff010162085200620001770701000e0700ff0101622c52ff6301f30177070100000200000101010109322e30312e3030310177070100605a02010101010105303246340177070100600500ff01010101650000000401010163682f00760400000362006200726500000201710163e8230000001b1b1b1b1a021af2";
		
		SMLMeterData data=SMLDecoder.decode(Hex.decodeHex(payload), false);
		
		System.err.println(data);
		
		assertThat(data).isNotNull();
		
		assertThat(data.getMeterId()).isEqualTo("1HLY0200384075");
		
		assertThat(data.getReadings())
			.isNotNull()
			.extracting(Object::toString)
			.containsExactlyInAnyOrder(
					 "1-0:1.8.0*255 / energyImportTotal = 7987194.8 WATT_HOUR",
					 "1-0:2.8.0*255 / energyExportTotal = 296486.8 WATT_HOUR",
					 "1-0:16.7.0*255 / powerTotal = 0 WATT",
					 "1-0:32.7.0*255 / voltageL1 = 230.7 VOLT",
					 "1-0:31.7.0*255 / currentL1 = 0.00 AMPERE",
					 "1-0:81.7.4*255 / phaseAngleIL1toUL1 = 0 DEGREE",
					 "1-0:14.7.0*255 / networkFrequency = 49.9 HERTZ"
				);

	}
	
	@Test
	public void testSMLDecoderEMH_ED300L() throws Exception {
		// a meter reported by a user as not decoded properly
		
		String payload="1b1b1b1b010101017607000c05de60f1620062007263010176010107000c0282cafb0b0901454d480000abd62a010163ea5f007607000c05de60f2620062007263070177010b0901454d480000abd62a070100620affff72620165028215f37e77078181c78203ff0101010104454d480177070100000000ff010101010f31454d48303031313236313438320177070100000009ff010101010b0901454d480000abd62a0177070100010800ff640102a001621e52ff5600034dd71f0177070100020800ff640102a001621e52ff560000116bbf0177070100010801ff0101621e52ff5600000000000177070100020801ff0101621e52ff560000116bbf0177070100010802ff0101621e52ff5600034dd71f0177070100020802ff0101621e52ff5600000000000177070100100700ff0101621b52ff55fffffdfe0177070100240700ff0101621b52ff55000000000177070100380700ff0101621b52ff55ffffed5301770701004c0700ff0101621b52ff55000010ab0177078181c78205ff010101018302c589dde68439c20d18cee93dbe78f31c5631ebd3c08854aca19472b39f1c2dd4179d445b05dfd68c3de8ca1a05bdc92c01010163d727007607000c05de60f562006200726302017101638e9e001b1b1b1b1a004c66";
		
		SMLMeterData data=SMLDecoder.decode(Hex.decodeHex(payload), false);
		
		System.err.println(data);
		
		assertThat(data).isNotNull();
		
		assertThat(data.getMeterId()).isEqualTo("1EMH0011261482");
		
		assertThat(data.getReadings())
			.isNotNull()
			.extracting(Object::toString)
			.containsExactlyInAnyOrder(
					 "1-0:1.8.0*255 / energyImportTotal = 5543299.1 WATT_HOUR",
					 "1-0:2.8.0*255 / energyExportTotal = 114169.5 WATT_HOUR",
					 "1-0:1.8.1*255 / energyImportTariff1 = 0.0 WATT_HOUR",
					 "1-0:2.8.1*255 / energyExportTariff1 = 114169.5 WATT_HOUR",
					 "1-0:1.8.2*255 / energyImportTariff2 = 5543299.1 WATT_HOUR",
					 "1-0:2.8.2*255 / energyExportTariff2 = 0.0 WATT_HOUR",
					 "1-0:16.7.0*255 / powerTotal = -51.4 WATT",
					 "1-0:36.7.0*255 / powerL1 = 0.0 WATT",
					 "1-0:56.7.0*255 / powerL2 = -478.1 WATT",
					 "1-0:76.7.0*255 / powerL3 = 426.7 WATT"
				);
	}
	
	@Test
	public void testSMLDecoder_eHZ_PW8E2A6L0HQ2D() throws Exception {
		// Test for issue reported in https://github.com/micw/tibber-pulse-reader/issues/15
		
		String payload="1b1b1b1b0101010176050013f6ff6200620072630101760107ffffffffffff050006a7ab0b0a01454d480000c312a17262016406aea2620163b7fa0076050013f70062006200726307017707ffffffffffff0b0a01454d480000c312a1070100620affff7262016406aea27577070100603201010101010104454d480177070100600100ff010101010b0a01454d480000c312a10177070100010800ff640801047262016406aea2621e52ff6403e05a0177070100020800ff017262016406aea2621e52ff6367540177070100100700ff0101621b520052240101016305eb0076050013f7016200620072630201710163fd5c001b1b1b1b1a000d95";
		
		SMLMeterData data=SMLDecoder.decode(Hex.decodeHex(payload), false);
		
		System.err.println(data);
		
		assertThat(data).isNotNull();
		
		assertThat(data.getMeterId()).isEqualTo("1EMH0012784289");
		
		assertThat(data.getReadings())
			.isNotNull()
			.extracting(Object::toString)
			.containsExactlyInAnyOrder(
					 "1-0:1.8.0*255 / energyImportTotal = 25404.2 WATT_HOUR",
					 "1-0:2.8.0*255 / energyExportTotal = 2645.2 WATT_HOUR",
					 "1-0:16.7.0*255 / powerTotal = 36 WATT"
				);
	}
	
	@Test
	public void testX() throws Exception {
		// Test for issue reported in https://github.com/micw/tibber-pulse-reader/issues/22
		
		String payload="1b1b1b1b01010101760484788603620062007263010176010102310b0a01445a470002b3c4747262006501467252620242cfa500760585788703420062007263070177010a0a01445a470003b3c474070100620affff72420165014772527477070100603200010172420162006200520004445a470077060100400100ff017262014200620052000a0a01445a470003b2c4740077070000010800ff641c01047262016200621e52ff440121f6a00176070100100700ff017262016200621b52fe5400a4b8000101633e140076058678870342006200726302017101630ae3001b1b1b1b1a005952";
		
		SMLMeterData data=SMLDecoder.decode(Hex.decodeHex(payload), false);
		
		System.err.println(data);
		
		assertThat(data).isNotNull();
		
		assertThat(data.getMeterId()).isEqualTo("1EMH0012784289");
		
		assertThat(data.getReadings())
			.isNotNull()
			.extracting(Object::toString)
			.containsExactlyInAnyOrder(
					 "1-0:1.8.0*255 / energyImportTotal = 25404.2 WATT_HOUR",
					 "1-0:2.8.0*255 / energyExportTotal = 2645.2 WATT_HOUR",
					 "1-0:16.7.0*255 / powerTotal = 36 WATT"
				);
	}
	
	
}
